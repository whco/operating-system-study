### 운영체제란 
운영체제 : 하드웨어를 관리하고, 응용 프로그램과 소프트웨어 사이의 인터페이스 역할을 하며, 시스템의 동작을 제어하는 시스템 소프트웨어
- 운영체제는 시스템의 동작과 자원을 관리하는 소프트웨어이다.
(시스템의 역할 구분에 따라 운영체제의 역할이 다를 수 있다)
- 운영체제의 역할
  - 프로세스 관리
    - 프로세스, 스레드
    - 스케쥴링
    - 동기화
    - IPC 통신
  - 저장장치 관리
    - 메모리 관리
    - 가상 메모리
    - 파일 시스템
  - 네트워킹
    - TCP/IP
    - 기타 프로토콜
  - 사용자 관리
    - 계정 관리
    - 접근권한 관리
  - 디바이스 드라이버
    - 순차접근 장치
    - 임의접근 장치
    - 네트워크 장치
#### 프로세스 관리
운영체제에서 작동하는 응용 프로그램을 관리한다. <br>
중앙 처리장치(CPU)가 점유해야 할 프로세스를 관리하고 실제로 CPU에 프로세스를 할당하며 공유 자원 접근과 통신 문제를 관리한다.

#### 저장장치 관리
- 1차 저장장치
  - 프로세스에 할당하는 메모리 영역의 할당과 해제
  - 메모리 간의 침범 방지
  - 메인 메모리의 효율적인 관리를 위한 가상 메모리 기능
- 2차 저장장치
  - 파일 형식의 데이터 저장
  - ssd, hdd 등에 파일 형식의 데이터 저장하여 관리하는 파일 시스템을 os에서 관리
  - FAT, NTFS, EXT2, JFS, XFS 등의 파일 시스템

#### 네트워킹
TCP/IP 기반의 인터넷에 연결하거나, 기타 네트워크 프로토콜을 os에서 지원하여야 네트워크 사용이 가능.

#### 사용자 관리
여러 사용자가 하나의 PC를 사용하는 환경 지원. 사용자별 시스템 자원이나 파일에 대한 접근권한과 보안 이슈 지원.

#### 디바이스 드라이버
운영체제는 시스템의 자원, 하드웨어를 관리한다. 시스템에는 여러 하드웨어가 존재하는데, <br> 
이를 운영체제에서 인식하고 관리하게 만들어 응용 프로그램에서 이를 사용할 수 있게 만들어야 한다. <br> 
따라서, 운영체제 안에 하드웨어를 추상화해 주는 계층이 필요하고, 이를 디바이스 드라이버라고 한다. 이러한 수 많은 디바이스 드라이버를 지원하고 관리하는 기능을 한다.


### 프로세스 & 스레드

#### 프로세스
프로그램 : 어떤 작업을 위해 실행할 수 있는 파일, 명령문 집합체
프로세스
- 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램
- 메모리에 올라와 실행되고 있는 프로그램의 인스턴스
- 운영체제로부터 시스템 자원을 할당받는 작업의 단위
  - 할당된 자원의 예
    - CPU 시간
    - 운영되기 위해 필요한 독립된 주소 공간
      - 다른 프로세스의 변수나 자료구조에 접근 불가
      - 접근 필요 시 IPC 통신 : 파이프, 파일, 소켓 등 이용
    - Code, Data, Stack, Heap의 구조로 되어 있는 독립된 메모리 영역
- 실행된 프로그램
프로세스의 상태전이
- 하나의 프로그램이 실행되면, 그 프로그램에 대응되는 프로세스가 생성되어 준비 리스트의 끝에 들어감.
- 준비 리스트 상의 다른 프로세스들이 CPU를 할당받아 준비 리스트를 떠나면, 그 프로세스는 점차 준비 리스트의 앞으로 이동해 언젠가 CPU를 사용할 수 있게 됨.
- 상태전이 관련 용어
  - 디스패치(dispatch) : 준비 리스트의 맨 앞에 있던 프로세스가 CPU를 점유하게 되는 것. 준비 상태 -> 실행 상태 <br>
    ``` dispatch (processname) : ready -> running ```
  - 보류(block) : 실행 상태의 프로세스가 허가된 시간을 다 쓰기 전에 입출력 동작을 필요로 하는 경우 프로세스가 스스로 CPU를 반납하고 보류 상태로 전환. <br>
    ``` block (processname) : running -> blocked ```
  - 깨움(wakeup) : 입출력 작업 종료 등 기다리던 사건이 일어났을 때 보류 상태에서 준비 상태로 넘어가는 과정 <br>
    ``` wakeup (processname) : blocked -> ready ```
  - 시간제한(timeout) : os에서 프로세스가 프로세서를 독점하지 못하게 clock interrupt를 두어 일정 시간동안만(tss의 time slice) 프로세서를 점유할 수 있게 함. <br>
    ``` timeout (processname) : running -> ready ```
#### 스레드
스레드
- 프로세스 내에서 실행되는 여러 흐름의 단위
- 프로세의 특정한 수행 경로
- 프로세스가 할당받은 자원을 이용하는 실행의 단위
- 각각의 스레드는 별도의 레지스터와 스택을 갖고 있지만, 힙 메모리는 서로 읽고 쓸 수 있다.
자바 스레드
- JVM이 운영체제의 역할을 한다.
- 자바에는 프로세스가 존재하지 않고 스레드만 존재
- JVM에 의해 전적으로 스케쥴링되는 실행 단위 코드 블록
  - > 블록 : 한 문단처럼 보이는 코드의 한 부분, 중괄호로 묶여 있는 경우가 많다.
- JVM이 관리하는 스레드 관련 항목
  - 스레드의 개수
  - 스레드로 실행되는 프로그램 코드의 메모리 위치
  - 스레드의 상태
  - 스레드의 우선순위

#### 멀티 프로세스
- 예시 : 멜론으로 음악을 들으면서 웹 서핑을 하는 경우
- 멜론 프로세스와 크롬 프로세스가 각각의 독립적인 cpu 및 메모리 자원을 할당받음
- 두 프로세스가 ~~병렬로~~ "병행"으로 실행, 병렬로도 가능.
  - 병렬로 실행하는 데 왜 context switching 발생하지????
    > - Context Switching : CPU가 한 개의 task(스레드 or 프로세스)를 실행하고 있는 상태에서 Interrupt 요청에 의해 다른 task로 실행이 전환되는 과정 <br>
    > ``` Interrupt : 주로 하드웨어를 통한 I/O 요청이나, OS / Driver 레벨의 Timer 기반 스케쥴링에 의해 발생 ```
    >   에서 기존의 task 상태 및 register 값들에 대한 정보 (Context)를 저장하고 새로운 task의 Context 정보로 교체하는 작업 <br>
    > - Context : CPU가 다루는 task에 대한 정보, 대부분 register에 저장하며 PCB로 관리 <br>
    >   - 프로세스는 os에 의해 PCB가 스케쥴링되고, 스레드는 프로세스 내부의 TCB(Task CB)라는 내부 구조를 통해 관리 <br>
    >   - Task의 PCB정보는 Process Stack, Ready Queue 라는 자료구조로 관리
    > - PCB에 저장되는 정보
    >   - Process State : 프로세스 상태
    >   - Program Counter : 다음에 실행할 명령어 Address
    >   - Register : 프로세스 레지스터 정보
    >   - Process number : 프로세스 번호
    - 의문 해결? : 엄밀히 말하면 병행으로 실행되고, 병렬로도 가능함. 병행 없이 병렬로만 실행되는 경우 context switching 발생 안 할 듯.
    - 오베허드 큼 : context switching 시프로세스 간 공유하는 메모리가 없어 캐시 메모리 초기화 후 다시 캐시 정보를 불러오는 등의 무거운 작업 매번 해 줘야 되기 때문
- 하기 때문에 서로 영향을 미치지 않음
  - 통신을 하지 않고서는 서로의 데이터에 접근 불가

장점 : 안전성(메모리 침범 문제를 os차원에서 해결) <br>
- 여러 프로세스 중 하나에 문제가 발생해도 그 프로세스만 죽이면 됨. 다른 프로세스로 영향 확산 안 됨
단점 : 각각 독립된 메모리 영역을 갖고 있어, 작업량 많을수록 오버헤드 발생. Context Switching으로 인한 성능 저하. 
- 자원 공유 필요 시 어렵고 복잡한 IPC 통신 요함.

#### 멀티 스레드

- 예시 : 카톡에서 파일전송을 하면서 메시지전송
- 두 스레드가 같은 heap, data 등 영역을 공유
- 윈도우, 리눅스 등 많은 운영체제들은 멀티 프로세스를 지원하지만 멀티 스레스가 기본
- **웹 서버** 는 대표적인 멀티 스레드 응용 프로그램 이다.
> 웹 서버 : 멀티스레드 서버, 싱글 스레드 서버  _ ```[참조](https://dheldh77.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%8B%B1%EA%B8%80%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%84%9C%EB%B2%84%EC%99%80-%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%84%9C%EB%B2%84)``` 
> 멀티 스레드 서버 : 
> <img src = "https://user-images.githubusercontent.com/57519837/143678469-02a4c116-2373-44dd-9803-76ffeea80820.png" width="30%" height="30%">
> - 웹 서버는 내부적으로 스레드 풀 유지
> - 클라이언트는 서버에 요청 전달
> - 스레드 풀 내 각각의 스레드가 blocking I/O 등 클라이언트 요청 처리 및 응답
> > [blocking, non-blocking IO, 동기, 비동기 개념 정리 참조](https://limdongjin.github.io/concepts/blocking-non-blocking-io.html#ibm-%E1%84%8B%E1%85%A1%E1%84%90%E1%85%B5%E1%84%8F%E1%85%B3%E1%86%AF)
> 싱글 스레드 서버 :
> <img src = "https://user-images.githubusercontent.com/57519837/143678582-04539a09-eda1-4e87-a8be-dfebaf3955d1.png" width="30%" height="30%">
> 서버 내부의 단일 스레드가 무한 루프를 돌며 클라이언트의 요청 대기(이벤트 루프 구조)
> > 이벤트 루프(메시지 디스패처, 메시지 루프, 메시지 펌프, 런 루프) : 프로그램의 이벤트나 메시지를 대기하다가 디스패치하는 프로그래밍 구조체
> > - 거의 무조건 메시지 제공자와 비동기식으로 동작
> - 클라이언트는 서버에 요청 전달
> - 서버는 복잡한 작업이나 Blocking I/O 등의 처리는 스레드 풀의 스레드에 작업을 넘기고 다음 클라이언트의 요청을 받음
> - Blocking I/O 등의 작업을 요청받은 스레드는 작업 수행 후 callback function을 통해 이벤트 루프 내 단일 스레드에 응답
> - 이벤트 루프 내 단일 스레드는 해당 클라이언트에 응답 전달


장점 : 독립적인 프로세스에 비해 공유 메모리만큼의 시간, 자원 손실이 감소. 전역 변수와 정적 변수에 대한 자료 공유 가능. <br>
- 시스템 자원 소모 감소(자원의 효율성 증대)
  - 프로세스를 생성해 자원을 할당하는 시스템 콜이 줄어들어 자원 효율적으로 관리.
  > 시스템 콜 : 운영체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스 
- 시스템 처리량 증가 (처리 비용 감소)
  - 스레드 간 통신 시간, 자원 소모 감소
  - 스레드 사이의 작업량이 적어 context switching이 빠름
- 간단한 통신 방법으로 프로그램 응답 시간 단축
  - stack 외 모든 메모리 공유해 통신의 부담이 적음
단점 : 안전성 문제. 한 스레드에서 예외 발생하거나 데이터 공간이 망가지면 모든 스레드에 영향
- critical section 기법을 통해 대비
> 하나의 스레드가 공유 데이터 값을 변경하는 시점에 다른 스레드가 그 값을 읽으려할 때 발생하는 문제 해결하기 위한 동기화 과정. <br>
> ```상호 배제, 진행, 한정된 대기 충족해야 함```
> critical section(임계 구(영)역, 공유변수 영역) : 둘 이상의 스레드가 동시에 접근해서는 안되는 공유 자원(자료 구조 또는 장치)을 접근하는 코드의 일부
> - 문제의 원인이 되는 코드 블록
> critical section 기법 : 열쇠를 들고 들어가고, 나와서는 열쇠를 문 앞에 둔다.
> - 이미 호출돼 있는 상태의 함수가 호출되려 하면 블로킹. 
> - 열쇠가 반환되면 블로킹을 빠져 나옴. EnterCriticalSection을 통해 임계영역에 들어가면 쓰레드가 크리티컬 섹션을 얻었다고 함.
> - LeaveCriticalSection을 통해 임계영역을 빠져 나와 열쇠를 걸어 둠. 크리티컬 섹션 오브젝트를 반환했다.
- 주의 깊은 설계 요구
- 디버깅이 까다로움
- 다른 프로세스에서 스레드를 제어할 수 없다. (프로세스 밖에서 스레드 각각 제어 불가)
- 자원 공유 문제(동기화 문제)
- 한 스레드 문제가 전체 프로세스에 영향
#### 자바의 스레드 스케쥴링
```자바의 스레드 스케줄링은 우선순위(Priority) 방식과 순환 할당(Round-Robin) 방식을 사용  _ from https://webcoding-start.tistory.com/62 ```
- 우선순위(Priority) 방식 : 우선순위가 높은 스레드가 실행 상태를 더 많이 가지도록 스케쥴링
  - 스레드 객체에 우선순위 번호를 부여할 수 있기 때문에 개발자가 코드로 제어 가능 : 1 ~ 10
  - 모든 스레드들은 기본적으로 5의 우선순위를 할당받습니다. 우선순위를 변경하고 싶다면 Thread 클래스가 제공하는 setPriority() 메소드를 이용
- 순환 할당(Round-Robin) 방식
  - 자바 가상 머신에 의해서 정해지기 때문에 코드로 제어할 수 없습니다.
- synchronized 접근제어자를 통해 잠금 부여

### 프로세스의 주소 공간
프로그램이 CPU에 의해 실행 -> 프로세스가 생성되고 프로세스 주소 공간이 할당됨.<br>
코드, 데이터, 스택으로 이루어짐
- 코드 segment : 프로그램 소스 코드 저장
- 데이터 segment : 전역 변수 저장
- 스택 segment : 함수, 지역 변수 저장
구역을 나누는이유: 
- 최대한 데이터를 공유하여 메모리 사용량을 줄이기 우해
- Code는 같은 프로그램 내 모두 같은 내용이므로 공유
- Stack과 데이터는 스택구조의 특성과 전역 변수의 활용을 위해
